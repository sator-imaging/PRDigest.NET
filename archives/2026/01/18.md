### 目次 {#table-of-contents}
1. [#123306 Add early return in TryGetLast for empty results.](#123306)

---
### [#123306](https://github.com/dotnet/runtime/pull/123306) Add early return in TryGetLast for empty results. {#123306}
- 作成者: [@prozolic](https://github.com/prozolic)
- 作成日時: 2026年01月17日 12:02:53(UTC)
- マージ日時: 2026年01月18日 16:08:55(UTC)
- ラベル: <span style="background-color: #d4c5f9; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">area-System.Linq</span> <span style="background-color: #c2e0c6; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">community-contribution</span>
#### 概要
`IEnumerableSkipTakeIterator.TryGetLast`に早期リターン最適化を追加し、Skip操作後に要素が存在しないことが確定した場合に即座に処理を終了します。`GetCount(onlyIfCheap: true)`が有効なカウントを返す場合、`count <= _minIndexInclusive`をチェックして不要な列挙を回避します。

```csharp
// 例：以下のシナリオが最適化対象
Enumerable.Range(0, 4).Prepend(4).Skip(5).LastOrDefault()
// Skip後に要素がないため、即座にfalseを返す
```

#### 変更内容
- **ファイル**: `src/libraries/System.Linq/src/System/Linq/SkipTake.SpeedOpt.cs`
  - `IEnumerableSkipTakeIterator.TryGetLast`メソッドにfast pathを追加
  - `count != -1`条件で安価なカウント取得時に最適化パスを開始
  - `count <= _minIndexInclusive`時の早期リターンロジック実装
  - 変更行数: +7/-1

#### パフォーマンスへの影響
**大幅な改善を確認**：
- `LastOrDefault_PrependSkip`: 54.05 ns → 25.75 ns（約**52%削減**）
- `LastOrDefault_AppendSkip`: 54.89 ns → 25.78 ns（約**53%削減**）
- `LastOrDefault_ConcatSkip`: 85.73 ns → 41.26 ns（約**52%削減**）

コードサイズも削減（例：2,616 B → 1,777 B）。メモリアロケーションはほぼ同等。Skip後に要素が存在しないシナリオで、不要な列挙処理を完全に回避できます。

#### 関連Issue
なし

#### その他
- 内部実装のみの変更（`SpeedOpt`内部メソッド）で、公開APIへの影響なし
- 破壊的変更なし
- LINQ `Skip().LastOrDefault()`パターンの最適化ケース

---
