### 目次 {#table-of-contents}
1. [#123557 Fix token memory ordering issue reading from the MethodDef and FieldDef token tables](#123557)
2. [#123551 Switch Windows build pools from VS2022 to VS2026 preview](#123551)
3. [#123527 Update Roslyn to 5.0.0-2.26070.104 and suppress IDE0071/IDE0031](#123527)
4. [#123518 Delete obsolete ETW logging scripts and update System.Net telemetry documentation](#123518)
5. [#123512 Do not try obtaining canonical dictionaries in `VirtualDispatchCellGenericLookupResult`](#123512)
6. [#123448 Enable runtime async for all libraries test projects](#123448)
7. [#123265 Replace explicit GTF_UNSIGNED flag operations with GenTree helper methods](#123265)
8. [#122862 \[RyuJIT Wasm\] Cast Operations Follow Up](#122862)
9. [#120336 Array.FindAll improvements](#120336)

---
### [#123557](https://github.com/dotnet/runtime/pull/123557) Fix token memory ordering issue reading from the MethodDef and FieldDef token tables {#123557}
- 作成者: [@davidwrighton](https://github.com/davidwrighton)
- 作成日時: 2026年01月23日 19:18:17(UTC)
- マージ日時: 2026年01月24日 04:18:23(UTC)
- ラベル: <span style="background-color: #d4c5f9; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">area-VM-coreclr</span>
#### 概要
MethodDef/FieldDefトークンテーブルの読み取り時にメモリ順序の問題を修正しました。TypeDefテーブルの読み取り成功後にMethodDef/FieldDefテーブルから値を読み込む際、明示的なメモリバリアがないため、CPUが依存順序を無視して先にMethodDef/FieldDefテーブルを読み込む可能性がありました。`VolatileLoad`を使用してメモリ順序を保証することで、この問題を解決しています。

#### 変更内容
- **src/coreclr/vm/ceeload.inl** (+14/-2)
  - MethodDef/FieldDefトークンマップテーブルからの読み取りに対して`VolatileLoad`を導入
  - 正しいメモリ順序を強制し、TypeDefテーブルの読み取り前にMethodDef/FieldDefテーブルが読み込まれることを防止

#### パフォーマンスへの影響
**わずかな性能低下**: `VolatileLoad`の導入により、メモリバリア命令が追加されるため、わずかなパフォーマンス低下が予想されます。ただし、メモリ順序の問題によるバグを確実に防止できる安全性の向上の方が重要です。

#### 関連Issue
- #120754（修正対象のIssue）

#### その他
このメモリ順序の問題は、マルチコアプロセッサ環境で再現性が低く難しい問題ですが、メタデータテーブル初期化時に発生する可能性があります。`VolatileLoad`を使用することで、複雑な依存順序ルールを正確に実装する手間を削減し、コード保守性を向上させています。

---
### [#123551](https://github.com/dotnet/runtime/pull/123551) Switch Windows build pools from VS2022 to VS2026 preview {#123551}
- 作成者: [@Copilot](https://github.com/apps/copilot-swe-agent)
- 作成日時: 2026年01月23日 15:59:11(UTC)
- マージ日時: 2026年01月24日 01:00:56(UTC)
- ラベル: 指定なし
#### 概要
.NET RuntimeのWindows CI/CDパイプラインをVisual Studio 2022からVisual Studio 2026プレビュー版へ移行するビルドインフラストラクチャの更新です。公式ビルド、パブリックビルド、ファジング、ストレステストの各パイプラインで使用するWindows ビルドプール イメージを一括切り替えました。

#### 変更内容
- **eng/pipelines/common/xplat-setup.yml**
  - Official builds: `windows.vs2022.amd64` → `windows.vs2026preview.scout.amd64`
  - Public builds: `windows.vs2022.amd64.open` → `windows.vs2026preview.scout.amd64.open`

- **eng/pipelines/libraries/fuzzing/deploy-to-onefuzz.yml**
  - ファジング ジョブ: `windows.vs2022.amd64` → `windows.vs2026preview.scout.amd64`

- **eng/pipelines/libraries/stress/ssl.yml**
  - SSL ストレステスト: `1es-windows-2022-open` → `windows.vs2026preview.scout.amd64.open`

- **eng/pipelines/libraries/stress/http.yml**
  - HTTP ストレステスト: `1es-windows-2022-open` → `windows.vs2026preview.scout.amd64.open`

#### パフォーマンスへの影響
影響なし。本変更はビルドインフラストラクチャの更新であり、コンパイラやランタイムの実装変更を含みません。ただし、VS2026プレビュー版のコンパイラ最適化やコード生成の改善により、ビルド性能やランタイム性能に間接的な影響が生じる可能性があります。

#### 関連Issue
#123550: Switch from VS2022 to VS2026 image

#### その他
- 本変更はマイナーなパイプライン構成の更新です
- VS2026プレビュー版の安定性検証が必要な場合は、ビルドやテスト結果を監視してください
- mainブランチへの適用とのことですが、release/10.0等の他ブランチへの展開については別途検討が必要な可能性があります

---
### [#123527](https://github.com/dotnet/runtime/pull/123527) Update Roslyn to 5.0.0-2.26070.104 and suppress IDE0071/IDE0031 {#123527}
- 作成者: [@Copilot](https://github.com/apps/copilot-swe-agent)
- 作成日時: 2026年01月23日 05:05:19(UTC)
- マージ日時: 2026年01月24日 00:37:30(UTC)
- ラベル: 指定なし
#### 概要
Roslyn/CodeAnalysisを4.14.0から5.0.0-2.26070.104へアップデートし、新しいアナライザーの厳密化に対応します。IDE0071（不要なToString()）とIDE0031（null伝播）をsilent診断に設定することで、`TreatWarningsAsErrors=true`での建築失敗を回避しつつ、IDE支援機能は保持します。

netstandard ターゲットではReadOnlySpan&lt;char&gt;を直接文字列補間できないため、ToString()呼び出しが必須となる点が抑制の理由です。

#### 変更内容
- **eng/Versions.props**: `MicrosoftCodeAnalysisVersion_LatestVS`を`4.14.0`→`5.0.0-2.26070.104`に更新
- **.editorconfig**: グローバル`[*.cs]`セクションに以下を追加
  - `dotnet_diagnostic.IDE0071.severity = silent`
  - `dotnet_diagnostic.IDE0031.severity = silent`

#### パフォーマンスへの影響
影響なし。本変更はアナライザーの構成変更であり、ランタイムパフォーマンスやコンパイル時間には影響しません。

#### 関連Issue
#123503（release/10.0からのバックポート：PR #123509）

#### その他
- このPRは`release/10.0`ブランチのPR #123509のmainブランチへのポートです
- 建築失敗が発生していたファイル：
  - System.Security.Cryptography.MLDsaCng.Windows.cs
  - System.Security.Cryptography.MLDsaImplementation.Windows.cs
  - System.Reflection.Metadata.TypeNameParser.cs

これらのファイルは.editorconfig設定により自動的に対応されます。

---
### [#123518](https://github.com/dotnet/runtime/pull/123518) Delete obsolete ETW logging scripts and update System.Net telemetry documentation {#123518}
- 作成者: [@Copilot](https://github.com/apps/copilot-swe-agent)
- 作成日時: 2026年01月22日 23:48:02(UTC)
- マージ日時: 2026年01月24日 00:59:46(UTC)
- ラベル: <span style="background-color: #d4c5f9; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">area-System.Net</span>
#### 概要
このPRは、廃止されたETW（Event Tracing for Windows）ログ取得ヘルパースクリプトを削除し、System.Net名前空間のデバッグドキュメントを公式のMicrosoft Learn テレメトリドキュメントへリダイレクトするものです。ローカルで管理されていた10個のMicrosoft-System-Net-* イベントソースのリストは削除され、メンテナンスされている公式ドキュメントを参照するよう更新されました。

#### 変更内容
- **削除ファイル:**
  - `src/libraries/Common/tests/Scripts/Tools/net_startlog.cmd` - ETWログ開始スクリプト
  - `src/libraries/Common/tests/Scripts/Tools/net_stoplog.cmd` - ETWログ停止スクリプト
  - `src/libraries/Common/tests/Scripts/Tools/net_providers.txt` - ネットワーキングイベントソースのGUID一覧

- **更新ファイル:**
  - `docs/workflow/debugging/libraries/windows-instructions.md` - System.Net名前空間セクションのドキュメント更新（ローカルスクリプト参照と硬コードされたイベントソースリストを削除、公式Microsoft Learnテレメトリドキュメント（https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/telemetry/overview）へのリンクを追加）

- **保持ファイル:**
  - `ParallelTestExecution.ps1` - 並列テスト実行用PowerShellユーティリティスクリプト

#### パフォーマンスへの影響
影響なし

#### 関連Issue
なし

#### その他
このPRはドキュメント保守性の向上を目的としています。ローカルで管理されていた廃止スクリプトと静的なイベントソースリストを削除することで、ドキュメントの鮮度を保ちやすくなります。ただし、公式Microsoft Learnドキュメントへの依存が増すため、リンク先の可用性を確認することが重要です。

---
### [#123512](https://github.com/dotnet/runtime/pull/123512) Do not try obtaining canonical dictionaries in `VirtualDispatchCellGenericLookupResult` {#123512}
- 作成者: [@MichalStrehovsky](https://github.com/MichalStrehovsky)
- 作成日時: 2026年01月22日 22:28:54(UTC)
- マージ日時: 2026年01月24日 02:08:01(UTC)
- ラベル: <span style="background-color: #d4c5f9; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">area-NativeAOT-coreclr</span>
#### 概要
PR #122012で導入されたリグレッションを修正するもので、AOTコンパイラが非具体的なジェネリック型に対して辞書ノードを作成しようとしていた問題を解決しています。`VirtualDispatchCellGenericLookupResult`では、非具体的なインスタンス化の場合、ジェネリック辞書の生成を試みないようにします。

#### 変更内容
**src/coreclr/tools/aot/ILCompiler.Compiler/Compiler/DependencyAnalysis/GenericLookupResult.cs**
- `VirtualDispatchCellGenericLookupResult.GetTarget`メソッドに条件分岐を追加
- `isConcreteInstantiation`フラグが真の場合のみ辞書ノードを作成するようにロジック修正
- 非具体的なインスタンス化からの参照では、辞書を構築しないため、呼び出し元の識別子パラメータは不要

#### パフォーマンスへの影響
影響なし。本修正はビルドエラーの修正であり、パフォーマンスへの直接的な影響はありません。ただし、outerloop（長時間実行テスト）が正常に完了するようになります。

#### 関連Issue
- #122012（本修正で回帰を修正したPR）

#### その他
このリグレッションはouterloopテストの実行段階で検出されており、以下のアサーション失敗が発生していました：
```
!owningType.IsCanonicalSubtype(CanonicalFormKind.Any)
   at ILCompiler.DependencyAnalysis.TypeGenericDictionaryNode..ctor
```
非具体的なジェネリック型に対するメタデータの処理を、AOTコンパイルパイプラインで正しく扱うための修正です。

---
### [#123448](https://github.com/dotnet/runtime/pull/123448) Enable runtime async for all libraries test projects {#123448}
- 作成者: [@agocke](https://github.com/agocke)
- 作成日時: 2026年01月21日 21:31:39(UTC)
- マージ日時: 2026年01月24日 08:35:51(UTC)
- ラベル: <span style="background-color: #A8F937; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">needs-area-label</span>
#### 概要
.NET 11以上のライブラリテストプロジェクトに対して、ランタイム非同期プレビュー機能を有効化します。サポートされていないシナリオは適切に除外されます。テストインフラストラクチャの設定ファイルで条件付きPropertyGroupを追加し、互換性のあるテストプロジェクトで機能を有効にします。

#### 変更内容
- **eng/testing/tests.targets**: 条件付きPropertyGroupを追加してランタイム非同期機能を互換性のあるテストプロジェクトで有効化（+13/-1）
- 92行目の末尾の空白文字を削除

#### パフォーマンスへの影響
ランタイム非同期プレビュー機能の有効化に伴うパフォーマンス特性の変化については、具体的なベンチマーク結果が提供されていないため、影響の詳細は不明です。この変更は主にテストプロジェクトの設定レベルの変更であり、本番環境への直接的な影響は限定的と考えられます。

#### 関連Issue
なし

#### その他
- この変更は .NET 11+ のテストプロジェクトを対象としており、それ以前のバージョンは影響を受けません
- サポートされていないシナリオは適切に除外される設計になっています
- テストインフラストラクチャの設定更新であるため、ビルドシステムに関連する変更です

---
### [#123265](https://github.com/dotnet/runtime/pull/123265) Replace explicit GTF_UNSIGNED flag operations with GenTree helper methods {#123265}
- 作成者: [@Copilot](https://github.com/apps/copilot-swe-agent)
- 作成日時: 2026年01月16日 17:56:49(UTC)
- マージ日時: 2026年01月24日 21:24:00(UTC)
- ラベル: 指定なし
#### 概要
JIT コンパイラの codebase において、GTF_UNSIGNED フラグの直接操作を既存の GenTree ヘルパーメソッドで置き換えるリファクタリング。55 個の明示的なフラグ操作を 22 ファイルにわたって `IsUnsigned()`、`SetUnsigned()`、`ClearUnsigned()` メソッドに統一し、コードの保守性と可読性を向上。

```csharp
// 変更前
gtFlags |= GTF_UNSIGNED;
if (gtFlags & GTF_UNSIGNED) { /* ... */ }
gtFlags &= ~GTF_UNSIGNED;

// 変更後
SetUnsigned();
if (IsUnsigned()) { /* ... */ }
ClearUnsigned();
```

#### 変更内容
- **gentree.h / gentree.cpp**: `SetUnsigned()` と `ClearUnsigned()` の実装を gentree.h からインライン宣言に変更し、gentree.cpp に実装を移行。デバッグアサーションを追加してノードオペレータ型を検証
- **JIT 処理パイプライン全体**: 22 ファイルで GTF_UNSIGNED フラグ操作を置き換え
  - `gtFlags |= GTF_UNSIGNED` → `SetUnsigned()` (13 箇所)
  - `gtFlags &= ~GTF_UNSIGNED` → `ClearUnsigned()` (3 箇所)
  - `(gtFlags & GTF_UNSIGNED)` → `IsUnsigned()` (39 箇所)
- **対象ノード**: 算術演算 (GT_ADD, GT_SUB)、キャスト (GT_CAST)、比較演算子、乗算操作 (GT_MUL, GT_MULHI, GT_MUL_LONG)

#### パフォーマンスへの影響
影響なし。本変更は純粋なコード品質改善であり、アルゴリズムやフラグ操作ロジックに変更なし。メソッド呼び出しはインライン化されるため、実行時オーバーヘッドなし。

#### 関連Issue
なし

#### その他
- CoreCLR ビルドが成功し、ランタイムテストもパス
- デバッグアサーション強化により、開発時に問題の診断が容易化
- API は非破壊的変更（既存ヘルパーメソッドの活用を拡大）

---
### [#122862](https://github.com/dotnet/runtime/pull/122862) [RyuJIT Wasm] Cast Operations Follow Up {#122862}
- 作成者: [@adamperlin](https://github.com/adamperlin)
- 作成日時: 2026年01月05日 04:51:13(UTC)
- マージ日時: 2026年01月24日 01:14:40(UTC)
- ラベル: <span style="background-color: #eb6420; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">arch-wasm</span> <span style="background-color: #d4c5f9; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">area-CodeGen-coreclr</span>
#### 概要
WebAssembly JIT のキャスト操作のコード生成を拡張するPRです。小整数型（byte、short）キャストの符号拡張対応、float→int のキャストが飽和非トラップ変換命令を使用して実装されました。Wasm オペコードを1バイトから2バイトに拡張し、`GenIntCastDesc` を條件付きコンパイル外に移動して Wasm 対応を強化しています。

```csharp
// float -> int の飽和変換の例（内部実装）
// float を int に変換する際、トラップせず範囲外の値を飽和値に変換
```

#### 変更内容
- **codegenwasm.cpp**: `genIntToIntCast`、`genFloatToIntCast`、`genFloatToFloatCast` メソッドの実装追加（+219行）
- **emitwasm.cpp**: オペコード型を `uint8_t` から `uint16_t` に変更し、2バイトオペコード出力ロジックを追加（+36行）
- **instrswasm.h**: ロード拡張、変換、飽和切り詰め命令を追加（+89行）
- **morph.cpp**: Wasm の float-to-long キャストでヘルパー呼び出しを回避
- **gentree.cpp**: Wasm キャスト操作のコスト推定を更新
- **codegen.h、codegenlinear.cpp**: `GenIntCastDesc` を `TARGET_64BIT` 条件外に移動して Wasm 対応を実現

#### パフォーマンスへの影響
**改善点:**
- float→int キャストが飽和非トラップ命令で直接実装され、ヘルパー関数呼び出しが削除されるため、オーバーヘッド削減
- 小整数型キャストの符号拡張が効率的に実装される

**懸念点:**
- オペコード型が 1 バイトから 2 バイトに拡張されることで、命令エンコーディングのサイズが若干増加する可能性
- ただし、ヘルパー呼び出し削減による全体的な改善が上回ると予想

#### 関連Issue
#122301（前回のレビューフィードバック対応）

#### その他
- **互換性**: 破壊的変更なし。Wasm 特有のコード生成ロジック追加のため、他のプラットフォーム（x86、ARM）への影響なし
- **コンテインメント未対応**: ロード内でのキャスト含有（`LOAD_*` タイプキャスト）はまだ未実装予定
- オペコード構造の拡張に伴い、命令フォーマットが 2 バイト対応に統一されており、将来の拡張性を確保

---
### [#120336](https://github.com/dotnet/runtime/pull/120336) Array.FindAll improvements {#120336}
- 作成者: [@Henr1k80](https://github.com/Henr1k80)
- 作成日時: 2025年10月02日 20:57:48(UTC)
- マージ日時: 2026年01月24日 03:29:10(UTC)
- ラベル: <span style="background-color: #d4c5f9; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">area-System.Runtime</span> <span style="background-color: #c2e0c6; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">tenet-performance</span> <span style="background-color: #c2e0c6; color: #000000; display: inline-block; padding: 0 7px; font-size:12px; font-weight:500; line-height:18px; border-radius:2em; border:1px solid transparent; white-space:nowrap; cursor:default;">community-contribution</span>
#### 概要
`Array.FindAll`メソッドのパフォーマンスを改善しました。マッチ結果をスタック上に一時的に格納し、Listの割り当てをオプション化することで、メモリ割り当てと実行速度の両方を削減します。.NET 10で利用可能な`InlineArray16<T>`を活用した実装です。

#### 変更内容
- **ファイル**: `src/libraries/System.Private.CoreLib/src/System/Array.cs`
  - 変更内容: `Array.FindAll`メソッドの実装を最適化
  - スタック割り当てバッファを使用してマッチ結果を一時格納
  - 必要な場合のみListを割り当てるようにロジックを変更

#### パフォーマンスへの影響
大幅な改善が実現されています：

**実行速度**: 32～54%まで改善（MatchAlwaysシナリオで最大56%削減）
- Size=5, MatchAlways: 12.565ns → 38.987ns（新/旧比: 0.32）

**メモリ割り当て**: 69～73%削減
- Size=5, MatchAlways: 48B → 176B（割り当て比: 0.27）
- MatchNeverシナリオ: 割り当てなし（新実装は0B）

**改善点**:
- マッチなしの場合、完全にヒープ割り当てが回避される
- スタック割り当てによるL1キャッシュ効率の向上
- 小～中規模配列での効果が顕著（サイズ1～9での測定）

**懸念点**:
- スタック割り当てサイズが固定のため、大規模マッチシナリオでは追加割り当てが発生する可能性あり

#### 関連Issue
なし

#### その他
- `.NET 8以下へのバックポートが必要な場合、ローカルの`InlineMatchArrayX<T>`構造体を作成する必要あり
- 複数の主要開発者による詳細なレビューを経ており、実装の堅牢性は確認済み

---
